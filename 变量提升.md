# 变量提升
    js引擎会一开始，就解析全局作用域中的所有var的变量和function
    会通过函数比undefined要大（留下的是函数），还要后面的函数会把前面的函数覆盖的原则进行变量值最后的赋值确认

    逐行解读代码：
            读打印，输出，赋值（=）
# 作用域
    域：范围  JS执行的范围（环境）
var 会在window上挂属性   let不会

- 全局作用域（window执行栈）
    如果有多个script标签，上一个script标签报错是不会影响下面script中的代码执行的
    查找的方式，先看当前的script有没有，没有还会去
- 局部作用域（函数中的执行栈）
    当函数执行的时候，开辟了一个执行栈，把函数中村的字符串运行在执行栈中
    1. 形参复制
    2. 变量提升
    3. 执行上下文
    4. 执行展销毁

        作用域链（Scope Chain）
        如果局部作用域中没有变量（var，let），函数，形参的时候，就会查找函数外面的变量，直到window为止

        ```
        var a =10
        function fn(){
            console.log(a)
        }
        fn()
        ```
        如果局部作用域只有变量（var，let），会直接找这个变量，是不会全局查找的

        ```
        var a =20
        function fn(){
            alert(a)   //undefined
            var a = 10
        }
        ```

        如果局部作用域中只有变量（var，let）还有形参，那么会优先形参

        ```
        var a =5
        function fn(a){
            alert(a)    5
            var a =10
            alert(a)    10
        }
        fn(a)
        ```

        如果局部作用域中有函数，变量（var,let） 还有形参，那么会优先函数体内的函数，并不是形参

        ```
        var a =function(){}
        function fn(a){
            alert(a)   // function a(){}
            var a = 10 
            alert(a)    // 10
            function a(){}
        }
        fn(a)
        ```
        - 块级作用域
        
## this 
        - 全局this window

            ```
            console.log(this)   window
            fn()   window
            
            匿名函数自执行
            (function(){
                console.log(this)  // window
            })
            ```

        - 事件this 事件触发对象

        ```
        btns.onclick = function(){
            console.log(this)  //btn
        }
        ```

        - 对象下的this  指向.前面的主

        ```
        obj = {
            style:{
                fn:function(){
                    console.log(this)
                }
            }
        }
        obj.style.fn()   //this -> obj.style
        ```
